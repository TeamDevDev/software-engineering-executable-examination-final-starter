{"amount_correct": 14, "percentage_score": 19, "report_time": "2023-12-14 13:08:30", "checks": [{"description": "Ensure that the README.md file exists inside of the root of the GitHub repository", "check": "ConfirmFileExists", "status": true, "path": "./README.md"}, {"description": "Delete the phrase 'Add Your Name Here' and add your own name as an Honor Code pledge in README.md", "check": "MatchFileFragment", "options": {"fragment": "Add Your Name Here", "count": 0, "exact": true}, "status": false, "path": "./README.md", "diagnostic": "Found 1 fragment(s) in the README.md or the output while expecting exactly 0"}, {"description": "Retype the every word in the Honor Code pledge in README.md", "check": "MatchFileFragment", "options": {"fragment": "I adhered to the Allegheny College Honor Code while completing this examination.", "count": 2, "exact": true}, "status": false, "path": "./README.md", "diagnostic": "Found 1 fragment(s) in the README.md or the output while expecting exactly 2"}, {"description": "Ensure that question_one.py file exists in the source/ directory", "check": "ConfirmFileExists", "status": true, "path": "source/question_one.py"}, {"description": "Complete all TODOs, remove the TODO markers, and rewrite comments for question_one.py", "check": "MatchFileFragment", "options": {"fragment": "TODO", "count": 0, "exact": true}, "status": false, "path": "source/question_one.py", "diagnostic": "Found 6 fragment(s) in the question_one.py or the output while expecting exactly 0"}, {"description": "Create a sufficient number of docstring (i.e., multiple-line) comments in question_one.py", "check": "CountMultipleLineComments", "options": {"language": "Python", "count": 12, "exact": true}, "status": false, "path": "source/question_one.py", "diagnostic": "Found 11 comment(s) in the question_one.py or the output"}, {"description": "Ensure that question_one.py follows an industry-standard programming rules using the command 'ruff check'", "command": "ruff check source/question_one.py", "status": false, "diagnostic": "source/question_one.py:132:9: F841 Local variable `current_empty_list` is assigned to but never used\n     source/question_one.py:227:5: D103 Missing docstring in public function\n     Found 2 errors.\n     No fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option)."}, {"description": "Ensure that question_one.py adheres to an industry-standard format using the command 'ruff format'", "command": "ruff format source/question_one.py --check", "status": false, "diagnostic": "Would reformat: source/question_one.py\n     1 file would be reformatted"}, {"description": "Ensure that question_one.py adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/question_one.py", "status": false, "diagnostic": "source/question_one.py:130: error: Need type annotation for \"empty_list_container\"  [var-annotated]\n     source/question_one.py:132: error: Need type annotation for \"current_empty_list\" (hint: \"current_empty_list: List[<type>] = ...\")  [var-annotated]\n     source/question_one.py:133: error: \"tuple[Any, ...]\" has no attribute \"append\"  [attr-defined]\n     source/question_one.py:134: error: Incompatible return value type (got \"tuple[Any, ...]\", expected \"list[list[int]]\")  [return-value]\n     Found 4 errors in 1 file (checked 1 source file)"}, {"description": "Ensure that source/question_one.py has correct number of fully type annotated functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --fully-typed -f source/question_one.py --count", "fragment": 7, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that source/question_one.py has correct number of documented functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --documented -f source/question_one.py --count", "fragment": 11, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that source/question_one.py has no undocumented functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --undocumented -f source/question_one.py --count", "fragment": 0, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run a program and confirm the correct number of non-blank lines in the output for question 1", "check": "CountCommandOutput", "options": {"command": "python source/question_one.py", "count": 3, "exact": true}, "status": false, "diagnostic": "Found 0 line(s) in the file or the output"}, {"description": "Run the program and confirm the existence of correct output for question 1-a", "check": "MatchCommandFragment", "options": {"command": "python source/question_one.py", "fragment": "No / Yes / Yes / No / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 1-b", "check": "MatchCommandFragment", "options": {"command": "python source/question_one.py", "fragment": "[[], [], [], [], []] / 5 / [[], [], [], []] / 4 / [[], [], []] / 3 / [[], []] / 2 / [[]] / 1", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 1-c", "check": "MatchCommandFragment", "options": {"command": "python source/question_one.py", "fragment": "Equilateral / Isosceles / Scalene / True / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that question_two.py file exists in the source/ directory", "check": "ConfirmFileExists", "status": true, "path": "source/question_two.py"}, {"description": "Complete all TODOs, remove the TODO markers, and rewrite comments for question_two.py", "check": "MatchFileFragment", "options": {"fragment": "TODO", "count": 0, "exact": true}, "status": false, "path": "source/question_two.py", "diagnostic": "Found 6 fragment(s) in the question_two.py or the output while expecting exactly 0"}, {"description": "Create a sufficient number of docstring (i.e., multiple-line) comments in question_two.py", "check": "CountMultipleLineComments", "options": {"language": "Python", "count": 14, "exact": true}, "status": false, "path": "source/question_two.py", "diagnostic": "Found 13 comment(s) in the question_two.py or the output"}, {"description": "Ensure that question_two.py follows an industry-standard programming rules using the command 'ruff check'", "command": "ruff check source/question_two.py", "status": false, "diagnostic": "source/question_two.py:68:5: D103 Missing docstring in public function\n     source/question_two.py:245:5: D205 1 blank line required between summary line and description\n     source/question_two.py:245:5: D212 [*] Multi-line docstring summary should start at the first line\n     source/question_two.py:259:5: D205 1 blank line required between summary line and description\n     source/question_two.py:259:5: D212 [*] Multi-line docstring summary should start at the first line\n     Found 5 errors.\n     [*] 2 fixable with the `--fix` option."}, {"description": "Ensure that question_two.py adheres to an industry-standard format using the command 'ruff format'", "command": "ruff format source/question_two.py --check", "status": false, "diagnostic": "Would reformat: source/question_two.py\n     1 file would be reformatted"}, {"description": "Ensure that question_two.py adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/question_two.py", "status": true}, {"description": "Ensure that source/question_two.py has correct number of fully type annotated functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --fully-typed -f source/question_two.py --count", "fragment": 9, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run a program and confirm the correct number of non-blank lines in the output for question 2", "check": "CountCommandOutput", "options": {"command": "python source/question_two.py", "count": 3, "exact": true}, "status": true}, {"description": "Run the program and confirm the existence of correct output for question 2-a", "check": "MatchCommandFragment", "options": {"command": "python source/question_two.py", "fragment": "False / False / False / False", "count": 1, "exact": true}, "status": true}, {"description": "Run the program and confirm the existence of correct output for question 2-b", "check": "MatchCommandFragment", "options": {"command": "python source/question_two.py", "fragment": "2 / 6 / 9 / 7 / Exception / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 2-c", "check": "MatchCommandFragment", "options": {"command": "python source/question_two.py", "fragment": "True / True / True / True / True / False", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that question_three.py file exists in the source/ directory", "check": "ConfirmFileExists", "status": true, "path": "source/question_three.py"}, {"description": "Complete all TODOs, remove the TODO markers, and rewrite comments for question_three.py", "check": "MatchFileFragment", "options": {"fragment": "TODO", "count": 0, "exact": true}, "status": false, "path": "source/question_three.py", "diagnostic": "Found 5 fragment(s) in the question_three.py or the output while expecting exactly 0"}, {"description": "Create a sufficient number of docstring (i.e., multiple-line) comments in question_three.py", "check": "CountMultipleLineComments", "options": {"language": "Python", "count": 11, "exact": true}, "status": false, "path": "source/question_three.py", "diagnostic": "Found 10 comment(s) in the question_three.py or the output"}, {"description": "Ensure that question_three.py follows an industry-standard programming rules using the command 'ruff check'", "command": "ruff check source/question_three.py", "status": false, "diagnostic": "source/question_three.py:134:5: D103 Missing docstring in public function\n     Found 1 error."}, {"description": "Ensure that question_three.py adheres to an industry-standard format using the command 'ruff format'", "command": "ruff format source/question_three.py --check", "status": false, "diagnostic": "Would reformat: source/question_three.py\n     1 file would be reformatted"}, {"description": "Ensure that question_three.py adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/question_three.py", "status": false, "diagnostic": "source/question_three.py:139: error: Incompatible return value type (got \"dict[str, float]\", expected \"dict[str, int]\")  [return-value]\n     Found 1 error in 1 file (checked 1 source file)"}, {"description": "Ensure that source/question_three.py has correct number of fully type annotated functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --fully-typed -f source/question_three.py --count", "fragment": 6, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run a program and confirm the correct number of non-blank lines in the output for question 3", "check": "CountCommandOutput", "options": {"command": "python source/question_three.py", "count": 3, "exact": true}, "status": true}, {"description": "Run the program and confirm the existence of correct output for question 3-a", "check": "MatchCommandFragment", "options": {"command": "python source/question_three.py", "fragment": "True / ['5', '7', '9', '11'] / False", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 3-b", "check": "MatchCommandFragment", "options": {"command": "python source/question_three.py", "fragment": "{'5': 5, '7': 7, '9': 9, '11': 11} / {'1': 1, '2': 2, '3': 3, '4': 4} / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 3-c", "check": "MatchCommandFragment", "options": {"command": "python source/question_three.py", "fragment": "{(5, 7, 9, 11): 32} / {(1, 2, 3, 4): 10} / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that question_four.py file exists in the source/ directory", "check": "ConfirmFileExists", "status": true, "path": "source/question_four.py"}, {"description": "Complete all TODOs, remove the TODO markers, and rewrite comments for question_four.py", "check": "MatchFileFragment", "options": {"fragment": "TODO", "count": 0, "exact": true}, "status": false, "path": "source/question_four.py", "diagnostic": "Found 5 fragment(s) in the question_four.py or the output while expecting exactly 0"}, {"description": "Create a sufficient number of docstring (i.e., multiple-line) comments in question_four.py", "check": "CountMultipleLineComments", "options": {"language": "Python", "count": 9, "exact": true}, "status": false, "path": "source/question_four.py", "diagnostic": "Found 8 comment(s) in the question_four.py or the output"}, {"description": "Ensure that question_four.py follows an industry-standard programming rules using the command 'ruff check'", "command": "ruff check source/question_four.py", "status": false, "diagnostic": "source/question_four.py:3:20: F401 [*] `typing.Dict` imported but unused\n     source/question_four.py:3:26: F401 [*] `typing.List` imported but unused\n     source/question_four.py:248:5: D103 Missing docstring in public function\n     Found 3 errors.\n     [*] 2 fixable with the `--fix` option."}, {"description": "Ensure that question_four.py adheres to an industry-standard format using the command 'ruff format'", "command": "ruff format source/question_four.py --check", "status": true}, {"description": "Ensure that question_four.py adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/question_four.py", "status": false, "diagnostic": "source/question_four.py:141: error: Incompatible return value type (got \"str\", expected \"bool\")  [return-value]\n     Found 1 error in 1 file (checked 1 source file)"}, {"description": "Ensure that source/question_four.py has correct number of fully type annotated functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --fully-typed -f source/question_four.py --count", "fragment": 4, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run a program and confirm the correct number of non-blank lines in the output for question 4", "check": "CountCommandOutput", "options": {"command": "python source/question_four.py", "count": 3, "exact": true}, "status": true}, {"description": "Run the program and confirm the existence of correct output for question 4-a", "check": "MatchCommandFragment", "options": {"command": "python source/question_four.py", "fragment": "True / True / False / False", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 4-b", "check": "MatchCommandFragment", "options": {"command": "python source/question_four.py", "fragment": "True / False / False / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 4-c", "check": "MatchCommandFragment", "options": {"command": "python source/question_four.py", "fragment": "11 / 1 / 10", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that question_five.py file exists in the source/ directory", "check": "ConfirmFileExists", "status": true, "path": "source/question_five.py"}, {"description": "Complete all TODOs, remove the TODO markers, and rewrite comments for question_five.py", "check": "MatchFileFragment", "options": {"fragment": "TODO", "count": 0, "exact": true}, "status": false, "path": "source/question_five.py", "diagnostic": "Found 5 fragment(s) in the question_five.py or the output while expecting exactly 0"}, {"description": "Create a sufficient number of docstring (i.e., multiple-line) comments in question_five.py", "check": "CountMultipleLineComments", "options": {"language": "Python", "count": 11, "exact": true}, "status": false, "path": "source/question_five.py", "diagnostic": "Found 10 comment(s) in the question_five.py or the output"}, {"description": "Ensure that question_five.py follows an industry-standard programming rules using the command 'ruff check'", "command": "ruff check source/question_five.py", "status": false, "diagnostic": "source/question_five.py:4:30: F401 [*] `typing.List` imported but unused\n     source/question_five.py:4:36: F401 [*] `typing.Tuple` imported but unused\n     source/question_five.py:193:5: D103 Missing docstring in public function\n     Found 3 errors.\n     [*] 2 fixable with the `--fix` option."}, {"description": "Ensure that question_five.py adheres to an industry-standard format using the command 'ruff format'", "command": "ruff format source/question_five.py --check", "status": false, "diagnostic": "Would reformat: source/question_five.py\n     1 file would be reformatted"}, {"description": "Ensure that question_five.py adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/question_five.py", "status": false, "diagnostic": "source/question_five.py:138: error: Incompatible return value type (got \"int\", expected \"str\")  [return-value]\n     Found 1 error in 1 file (checked 1 source file)"}, {"description": "Ensure that source/question_five.py has correct number of fully type annotated functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --fully-typed -f source/question_five.py --count", "fragment": 3, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run a program and confirm the correct number of non-blank lines in the output for question 5", "check": "CountCommandOutput", "options": {"command": "python source/question_five.py", "count": 3, "exact": true}, "status": false, "diagnostic": "Found 0 line(s) in the file or the output"}, {"description": "Run the program and confirm the existence of correct output for question 5-a", "check": "MatchCommandFragment", "options": {"command": "python source/question_five.py", "fragment": "7", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 5-b", "check": "MatchCommandFragment", "options": {"command": "python source/question_five.py", "fragment": "[INFO] Opened the file / [WARNING] Executed dangerous if statement / [CRITICAL] Unresolved network error", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 5-c", "check": "MatchCommandFragment", "options": {"command": "python source/question_five.py", "fragment": "(12, 10, '>') / (3, 9, '<') / (2, 2, '=') / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that question_six.py file exists in the source/ directory", "check": "ConfirmFileExists", "status": true, "path": "source/question_six.py"}, {"description": "Complete all TODOs, remove the TODO markers, and rewrite comments for question_six.py", "check": "MatchFileFragment", "options": {"fragment": "TODO", "count": 0, "exact": true}, "status": false, "path": "source/question_six.py", "diagnostic": "Found 10 fragment(s) in the question_six.py or the output while expecting exactly 0"}, {"description": "Create a sufficient number of docstring (i.e., multiple-line) comments in question_six.py", "check": "CountMultipleLineComments", "options": {"language": "Python", "count": 11, "exact": true}, "status": false, "path": "source/question_six.py", "diagnostic": "Found 8 comment(s) in the question_six.py or the output"}, {"description": "Ensure that question_six.py follows an industry-standard programming rules using the command 'ruff check'", "command": "ruff check source/question_six.py", "status": false, "diagnostic": "source/question_six.py:1:1: D100 Missing docstring in public module\n     source/question_six.py:1:8: F401 [*] `random` imported but unused\n     source/question_six.py:2:26: F401 [*] `typing.Tuple` imported but unused\n     source/question_six.py:150:5: D103 Missing docstring in public function\n     source/question_six.py:220:5: D103 Missing docstring in public function\n     Found 5 errors.\n     [*] 2 fixable with the `--fix` option."}, {"description": "Ensure that question_six.py adheres to an industry-standard format using the command 'ruff format'", "command": "ruff format source/question_six.py --check", "status": false, "diagnostic": "Would reformat: source/question_six.py\n     1 file would be reformatted"}, {"description": "Ensure that question_six.py adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/question_six.py", "status": false, "diagnostic": "source/question_six.py:152: error: Incompatible return value type (got \"list[list[int]]\", expected \"list[list[str]]\")  [return-value]\n     Found 1 error in 1 file (checked 1 source file)"}, {"description": "Ensure that source/question_six.py has correct number of fully type annotated functions using the command 'symbex'", "check": "MatchCommandFragment", "options": {"command": "symbex -s --fully-typed -f source/question_six.py --count", "fragment": 6, "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run a program and confirm the correct number of non-blank lines in the output for question 6", "check": "CountCommandOutput", "options": {"command": "python source/question_six.py", "count": 3, "exact": true}, "status": true}, {"description": "Run the program and confirm the existence of correct output for question 6-a", "check": "MatchCommandFragment", "options": {"command": "python source/question_six.py", "fragment": "(0, 0) / (1, 1) / (2, 2) / (3, 3)", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 6-b", "check": "MatchCommandFragment", "options": {"command": "python source/question_six.py", "fragment": "(0, 0) / (3, 2) / (2, 3) / (1, 1)", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Run the program and confirm the existence of correct output for question 6-c", "check": "MatchCommandFragment", "options": {"command": "python source/question_six.py", "fragment": "0, True) / True", "count": 1, "exact": true}, "status": false, "diagnostic": "Found 0 fragment(s) in the file or the output while expecting exactly 1"}, {"description": "Ensure that all source code adheres to an industry-standard format using the command 'mypy'", "command": "mypy source/*.py", "status": false, "diagnostic": "source/question_three.py:139: error: Incompatible return value type (got \"dict[str, float]\", expected \"dict[str, int]\")  [return-value]\n     source/question_one.py:130: error: Need type annotation for \"empty_list_container\"  [var-annotated]\n     source/question_one.py:132: error: Need type annotation for \"current_empty_list\" (hint: \"current_empty_list: List[<type>] = ...\")  [var-annotated]\n     source/question_one.py:133: error: \"tuple[Any, ...]\" has no attribute \"append\"  [attr-defined]\n     source/question_one.py:134: error: Incompatible return value type (got \"tuple[Any, ...]\", expected \"list[list[int]]\")  [return-value]\n     source/question_four.py:141: error: Incompatible return value type (got \"str\", expected \"bool\")  [return-value]\n     source/question_five.py:138: error: Incompatible return value type (got \"int\", expected \"str\")  [return-value]\n     source/question_six.py:152: error: Incompatible return value type (got \"list[list[int]]\", expected \"list[list[str]]\")  [return-value]\n     Found 8 errors in 5 files (checked 6 source files)"}]}